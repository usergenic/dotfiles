#! /bin/bash

# Using different SSH identities based on Git repo's configured user.email
export GIT_SSH=$HOME/bin/git-ssh

# Find a branch (local or remote) matching search string
git_branch_find() {
  local search="$1"
  local escaped_search=$(printf '%s\n' "$search" | sed 's/[[\.*^$()+?{|]/\\&/g')
  git branch --all | sed 's|^[[:space:]]*\*[[:space:]]*||' | sed 's|^[[:space:]]*||' | sed 's|^remotes/origin/||' | sed 's|^remotes/||' | grep -E ".*${escaped_search}.*\$" | sort | uniq
}

# Find a branch exactly matching given string
git_branch_find_exact() {
  local search="$1"
  local escaped_search=$(printf '%s\n' "$search" | sed 's/[[\.*^$()+?{|]/\\&/g')
  git_branch_find "$search" | grep -E "^${escaped_search}\$"
}

# Get the current branch name of a git repo
git_branch_name() {
  branch_name=$(command git symbolic-ref --short HEAD 2>/dev/null)

  if test -z "$branch_name"
  then
    local tag_name=$(command git describe --tags --exact-match HEAD 2>/dev/null)
    if test -z "$tag_name"
    then
      command git rev-parse --short HEAD 2>/dev/null
    else
      printf "%s\n" "$tag_name"
    fi
  else
    printf "%s\n" "$branch_name"
  fi
}

# Test if the current directory is within a Git repository
git_is_repo() {
  if command git rev-parse --git-dir 1>/dev/null 2>/dev/null
  then
    return 0
  else
    return 1
  fi
}

# Test if there are any changes in the working tree
git_is_touched() {
  if git_is_repo
  then
    command git status --porcelain 1>/dev/null | command awk '
        // {
            z++
            exit 0
        }

        END {
            exit !z
        }
    '
  else
    return 1
  fi
}

# Find a local branch matching search string
git_local_branch_find() {
  local search="$1"
  local escaped_search=$(printf '%s\n' "$search" | sed 's/[[\.*^$()+?{|]/\\&/g')
  git branch | sed 's|^[[:space:]]*\*[[:space:]]*||' | sed 's|^[[:space:]]*||' | grep -E ".*${escaped_search}.*\$" | sort | uniq
}

# Find a local branch exactly matching given string
git_local_branch_find_exact() {
  local search="$1"
  local escaped_search=$(printf '%s\n' "$search" | sed 's/[[\.*^$()+?{|]/\\&/g')
  git_local_branch_find "$search" | grep -E "^${escaped_search}\$"
}

# Get the top level directory of the current git repository
git_repository_root() {
  if git_is_repo
  then
    command git rev-parse --show-toplevel
  else
    return 1
  fi
}

# Deletes the directory and branch for the matching worktree
git_worktree_delete() {
  if test $# -ne 1
  then
    echo "only one argument accepted by git_worktree_delete"
    return 1
  fi

  local existing_worktree=$(git_worktree_find "$1")
  local worktree_count=$(echo "$existing_worktree" | wc -w)

  if test $worktree_count -eq 0
  then
    echo "no worktree matches"
    return 1
  fi

  if test $worktree_count -gt 1
  then
    echo "multiple worktree matches:"
    echo "$existing_worktree"
    return 1
  fi

  echo "Deleting worktree $existing_worktree"

  cd "$existing_worktree"
  if git_is_touched
  then
    echo "unsaved changes in worktree. aborting"
    return 1
  fi

  local branch_name=$(git_branch_name)

  # switch to main worktree after delete
  git_worktree_open main
  rm -rf "$existing_worktree"
  git worktree prune
  git branch -D "$branch_name"
}

# Get the name of the branch of the worktree that matches search string
git_worktree_find() {
  local search="$1"
  local escaped_search=$(printf '%s\n' "$search" | sed 's/[[\.*^$()+?{|]/\\&/g')
  local exact_result=$(git worktree list | grep -E "\\[${escaped_search}\\]" | grep -oE '^[^ ]+')
  local exact_count=$(echo "$exact_result" | wc -w)
  if test $exact_count -eq 1
  then
    echo "$exact_result"
    return 0
  fi
  git worktree list | grep -E "\\[.*${escaped_search}.*\\]" | grep -oE '^[^ ]+'
}

# Find or create a git worktree for branch
git_worktree_open() {
  if test $# -ne 1
  then
    echo "only one argument accepted by git_worktree_open"
    return 1
  fi

  local existing_worktree=$(git_worktree_find "$1")
  local worktree_count=$(echo "$existing_worktree" | wc -w)

  if test $worktree_count -eq 1
  then
    cd "$existing_worktree"
    return 0
  fi

  if test $worktree_count -gt 1
  then
    echo "multiple worktree matches:"
    echo "$existing_worktree"
    return 1
  fi

  local existing_branch=$(git_branch_find_exact "$1" || git_branch_find "$1")
  local existing_local_branch=$(git_local_branch_find_exact "$1" || git_local_branch_find "$1")
  local branch_count=$(echo "$existing_branch" | wc -w)
  local local_branch_count=$(echo "$existing_local_branch" | wc -w)

  if test $branch_count -gt 1
  then
    echo "multiple branch matches:"
    echo "$existing_branch"
    return 1
  fi

  if test $branch_count -eq 0
  then
    local branch_name="$1"
    echo "creating branch and adding worktree for '$branch_name'"
  fi

  if test $branch_count -eq 1
  then
    local branch_name="$existing_branch"
    # Strip any remote prefixes that might have slipped through
    branch_name=$(echo "$branch_name" | sed 's|^remotes/origin/||' | sed 's|^remotes/||')
    echo "adding worktree for existing branch '$branch_name'"
  fi

  local repo_basedir=$(git_repository_root | grep -oE "^[^~]+")
  local embeddable_branch_name=$(echo "$branch_name" | sed 's/[^a-zA-Z0-9_]/-/g')
  local worktree_dir="$repo_basedir~$embeddable_branch_name"

  if test $branch_count -eq 0
  then
    git worktree add -b "$branch_name" "$worktree_dir"
  fi

  if test $branch_count -eq 1
  then
    if test $local_branch_count -eq 0
    then
      local temp_branch=git_worktree_open.temp
      git worktree add -b "$temp_branch" "$worktree_dir"
      cd "$worktree_dir"
      git checkout "$branch_name"
      git branch -D "$temp_branch"
      git worktree prune
    else
      git worktree add "$worktree_dir" "$branch_name"
    fi
  fi

  cd "$worktree_dir"
}

alias gb="git branch"
alias gbf="git_branch_find"
alias gp="git push --set-upstream origin \$(git_branch_name)"
alias gwo="git_worktree_open"
alias gwd="git_worktree_delete"
alias gwl="git worktree list"
